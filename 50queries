#1
[SELECT | FROM | WHERE]

select * from sales.customers
where city = 'houston'

![210_IMG1](https://user-images.githubusercontent.com/55178196/68712151-f89fd100-054f-11ea-96f3-ee71ddc78429.PNG)

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-select/

Analysis:
/* The classic SELECT statement selects FROM a schema ('sales'),
   while 'customers' is the table that is related to 'sales.'
   Therefore using FROM statement should have format like this
   [schema_name.table_name]

   WHERE statement can further specify the condition of the query 
   that it will further narrowing down the search. 
   WHERE statement along with HAVING, GROUP BY, ORDER BY,
   and others are SQL Clauses.
*/

-----------------------------------------------------

#2
[WHERE | GROUP BY | ORDER BY]

SELECT
    first_name,
    last_name,
    customer_id
FROM
    sales.customers
WHERE
    customer_id >= 20
GROUP BY
    first_name,
    last_name,
    customer_id
ORDER BY
    customer_id

[210_IMG2]

Source: Self Programmed Query

Analysis:
/* With ORDER BY, I can sort the table specified in an ascending 
   order. In this example, I have used 'customer_id' to be sorted.
   Noticed that 'customer_id' started with 20, which that is because
   the WHERE have a condition that 'customer_id' is at or more than 20.
*/

---------------------------------------------------------------

#3
[HAVING]

SELECT
    first_name,
    last_name,
    customer_id
FROM
    sales.customers
WHERE
    customer_id BETWEEN 20 AND 30
GROUP BY
    first_name,
    last_name,
    customer_id
HAVING 
    customer_id >25	
ORDER BY
    customer_id

[210_IMG3]

Source: Self Programmed Query

/* HAVING clause works with a condition and the condition in the
   example is 'customer_id' is more than 25. Even though I can specify
   than in the WHERE clause, however, this to shows that WHERE and HAVING
   can be in the same query. 
*/

-----------------------------------------------------------------

#4
[HAVING AND WHERE Comparison]

SELECT
    first_name,
    last_name,
    customer_id,
    state
FROM
    sales.customers
WHERE
    zip_code >= 30000
GROUP BY
    first_name,
    last_name,
    customer_id,
    state
HAVING 
    customer_id >25	
ORDER BY
    state

[210_IMG4]

Source: Self Programmed Query

Analysis:
/* WHERE clause can be based off on any column in the base table and 
   HAVING clause only can refer to the result of the SELECT statement 
   or the GROUP BY clause.
   To illustrate this concept, the WHERE clause is set to have condition
   of a 'zipcode' table that is or higher than 30000. Notice that zipcode
   are not part of the SELECT statement. Whereas HAVING is bound by the 
   SELECT and GROUP BY
*/

--------------------------------------------------------------------------
#5
[SELECT DISTINCT]

SELECT DISTINCT state

from sales.customers;

[210_IMG5]

/* SELECT DISTINCT as simple as it may seems, it does the same thing as
   query #1 does, which it is to narrow down the search in a particular 
   search but with leaving out WHERE clause. I believe the reasoning behind 
   it for using distinct instead of WHERE clause, is when you know exactly 
   what you're searching and that the search will return with a true result
   instead of WHERE clause that is a condition, and that condition may or may
   not return a true result. 
*/

---------------------------------------------------------------------------------

#6
[LIKE operator]

SELECT first_name, email, city, state, zip_code
FROM sales.customers
WHERE email LIKE '%gmail%';

[210_IMG6]

/* The query I was looking for in the bike shop is to find the first name, email,
   city, state and zipcodes of users that have email account that is GMAIL. 
   Therefore in this query I have used the WHERE clause to define the condition
   and LIKE operator to filter the results from the sales.customer table with the 
   specific result list using SELECT statement
*/

----------------------------------------------------------------------------------

#7
[NULL logic]

SELECT *
FROM sales.customers
WHERE phone is NULL

[210_IMG7]

/* The NULL logic is used to find empty value by assigning it to a search condition
   or clause. Which in this case, I will be using WHERE clause to find customer's 
   contact information that does not have a phone number. From a business perspective,
   I'll be able to email or send them a personal letter to connect and build relationships
   with the customers, as well as updating personal information such as phone number.
   I specifically SELECT all columns, which is the customer contact information, but 
   with the result with only customers that do not have phone number on file in the database.
*/

----------------------------------------------------------------------------------

#8
[AND operator]

SELECT *
FROM sales.customers
WHERE phone is NULL
AND state = 'CA'
AND zip_code < 93000
ORDER BY zip_code ASC;

[210_IMG8]

/* The AND operator is a boolean expression where it would return a value that is 
   either TRUE, FALSE, or UNKNOWN. I'm using the previous query result to showcase 
   AND operator to find a specific state in which in the example would be CA and 
   I further define the condition to be zipcode number would be anything below '93000.' 
*/

----------------------------------------------------------------------------------

#9
[OR operator]

SELECT *
FROM
    production.products
WHERE
category_id = 6
or
brand_id > 7
ORDER BY list_price ASC;

[210_IMG9]

/* The OR operator would take the condition define and combine them as a result if
   the condition result is TRUE. In the example, I placed 2 conditions to be met 
   where category by ID have to be 6 and brand ID can be anything above 7, and then
   order them by ascending in price.
*/

----------------------------------------------------------------------------------

#10
[BETWEEN operator]

SELECT *
FROM
    production.products
WHERE
category_id = 6 or category_id = 7
ORDER BY list_price ASC;
-------------------------------------
SELECT *
FROM
    production.products
WHERE
category_id between 6 and 7
ORDER BY list_price ASC;

[210_IMG10]

/* The BETWEEN operator works like the < and > comparison and both can replace BETWEEN
   and would work the same. Another operator that would give the same result would be
   the OR operator.
*/

----------------------------------------------------------------------------------

#11
[Alias]

SELECT first_name + ' ' + last_name AS Full_Name, 
       city + ', ' + state AS Location
FROM sales.customers
ORDER BY state;

[210_IMG11]

/* Alias work by putting 'AS' to combine two information into one and named it
   entirely different. In the example, I have took the last name and first name 
   combined it to make the full name. Same as for the location. This makes the data
   information more complete for user to read it easily.
*/

----------------------------------------------------------------------------------

#12
[Alias] 

SELECT 
    product_name 'Products', list_price 'Price'
FROM 
    production.products
ORDER BY 
   'Price';

[210_IMG12]

/* While the example above combines information of 2 columns, this example shows 
   that alias can be assigned to a column without the combination and without
   'AS' 
*/

----------------------------------------------------------------------------------

#13
[GROUP BY]

SELECT
    customer_id,
    YEAR (order_date) order_year,
    COUNT (order_id) order_placed
FROM
    sales.orders
WHERE
    customer_id IN (1, 2)
GROUP BY
    customer_id,
    YEAR (order_date)
ORDER BY
    customer_id; 

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-group-by/

[210_IMG13]

/* This query with GROUP BY clause uses aggregate function like 'COUNT' to perform
   calculation. For this matter, the count will increase by the number of times
   the customer would order each year based on customer_id and order_id.
*/

----------------------------------------------------------------------------------

#14
[GROUP BY]

SELECT
    city,
    COUNT (customer_id) customer_count
FROM
    sales.customers
GROUP BY
    city
ORDER BY
    city;

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-group-by/

[210_IMG14]

/* Just like the example on #13, this type of queries can improve the quality of
   business strategy in a company. If a specific location that has low customer 
   count but in a large city (ratio of customer to number of people in the city)
   then maybe this bike store strategies marketing effort in the specific location.
*/

----------------------------------------------------------------------------------

#15
[Aggregate Functions]

SELECT
    brand_name,
    MIN (list_price) min_price,
    MAX (list_price) max_price
FROM
    production.products p
INNER JOIN production.brands b ON b.brand_id = p.brand_id
WHERE
    model_year = 2018
GROUP BY
    brand_name
ORDER BY
    brand_name;

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-group-by/

[210_IMG15]

/* Using MIN and MAX, this query is able to pull information from list_price and
   run calculation of the minimum and maximum price sorted by brand name and model
   year. As goes to analysis of possible bike category and also the spending from
   each city or state. Just a simple query provides valuable information in helping
   to analyse a business strategy.
*/

----------------------------------------------------------------------------------

#16
[Subqueries]

SELECT
    product_name,
    list_price
FROM
    production.products
WHERE
    list_price > (
        SELECT
            AVG (list_price)
        FROM
            production.products
        WHERE
            brand_id IN (
                SELECT
                    brand_id
                FROM
                    production.brands
                WHERE
                    brand_name = 'Strider'
                OR brand_name = 'Trek'
            )
    )
ORDER BY
    list_price;

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-subquery/

[210_IMG16]

/* This query is example of a subquery nesting where if information and filteration
   of data is complex, then subqueries can be used. In SQL Server, subqueries can be
   used up to 32 levels of nesting.
*/

----------------------------------------------------------------------------------

#17
[Subqueries and Expression]

SELECT
    order_id,
    order_date,
    (
        SELECT
            MAX (list_price)
        FROM
            sales.order_items i
        WHERE
            i.order_id = o.order_id
    ) AS max_list_price
FROM
    sales.orders o
order by order_date desc;

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-subquery/

[210_IMG17]

/* Within the subquery and nesting, expression can further narrow down the data
   information. In this example, the expression compute the maximum price from 
   list_price and list it as max_list_price within the subquery nesting.
*/

----------------------------------------------------------------------------------

#18
[EXIST operator]

SELECT
    customer_id,
    first_name,
    last_name,
    city
FROM
    sales.customers c
WHERE
    EXISTS (
        SELECT
            customer_id
        FROM
            sales.orders o
        WHERE
            o.customer_id = c.customer_id
        AND YEAR (order_date) = 2017
    )
ORDER BY
    first_name,
    last_name;

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-subquery/

[210_IMG18]

/* Using the subquery example, this query also illustrate the EXIST operator where
   if the subquery return result, then the EXIST operator will return TRUE. This 
   example would find customers that bought products from the bike store in the year
   of 2017.
*/

----------------------------------------------------------------------------------

#19
[Correlation subquery]

SELECT
    customer_id,
    first_name,
    last_name
FROM
    sales.customers c
WHERE
    EXISTS (
        SELECT
            COUNT (*)
        FROM
            sales.orders o
        WHERE
            customer_id = c.customer_id
        GROUP BY
            customer_id
        HAVING
            COUNT (*) > 2
    )
ORDER BY
    first_name,
    last_name;

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-subquery/

[210_IMG19]

/* Within this query, it uses EXIST within a subquery and also HAVING clause that
   includes count more than 2. It means that this query would find customers that 
   have ordered from the bike store for more than twice. This query can also further
   break down into by year, city or state.
*/

----------------------------------------------------------------------------------

#20
[UNION]

SELECT
    first_name,
    last_name
FROM
    sales.staffs
UNION ALL
SELECT
    first_name,
    last_name
FROM
    sales.customers;

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-union/

[210_IMG20]

/* Using union, it combines rows from queries into a single result set where in 
   this example, it combines the first name and last name from staffs and customers
   into a single result set.
*/

----------------------------------------------------------------------------------
#21
[SCHEMA]

CREATE SCHEMA hr;

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-joins/

[210_IMG21]

/* Using create, I can create schema or even tables into the schema
*/

----------------------------------------------------------------------------------

#22
[CREATE]

CREATE TABLE hr.candidates(
    id INT PRIMARY KEY IDENTITY,
    fullname VARCHAR(100) NOT NULL
);
 
CREATE TABLE hr.employees(
    id INT PRIMARY KEY IDENTITY,
    fullname VARCHAR(100) NOT NULL
);

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-joins/

[210_IMG22]

/* Using create, I can create schema or even tables into the schema. The 'id'
   will be the PRIMARY KEY and would contain full name.
*/

----------------------------------------------------------------------------------

#24
[I]

INSERT INTO 
    hr.candidates(fullname)
VALUES
    ('Kenneth Monroe'),
    ('Lewis Wang'),
    ('Peter Chap'),
    ('Jane Lane');
 
 
INSERT INTO 
    hr.employees(fullname)
VALUES
    ('Kenny Lew'),
    ('Joe Langley'),
    ('Michael Scotty'),
    ('Jack Sparrow');

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-joins/

[210_IMG23]

/* Insert into is self explanatory where I can enter information regarding 
   the table I've just created. All those values will be inserted into candidates
   and employees tables under 'hr' schema respectively.
*/

----------------------------------------------------------------------------------

#24
[INNER JOIN]

SELECT  
    c.id ,
    c.fullname ,
    e.id ,
    e.fullname 
FROM 
    hr.candidates c
    INNER JOIN hr.employees e 
        ON e.fullname = c.fullname;
    

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-joins/

[210_IMG24]

/* Basically by selecting 'id' and 'fullname' from 'c' which is the customer, and
   the same for employee, to joint them when the condition (fullname that is in both
   employee and candidate) is met. This is to ensure that HR department able to clean
   up candidate records if and when the candidate is hired as an employee but would 
   still have records as a candidate.
*/

----------------------------------------------------------------------------------

#25
[Header]

SELECT  
    c.id candidate_id,
    c.fullname candidate_name,
    e.id employee_id,
    e.fullname employee_name
FROM 
    hr.candidates c
    INNER JOIN hr.employees e 
        ON e.fullname = c.fullname;
    

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-joins/

[210_IMG25]

/* The same as example #24, I can rename/replace the header with any name that 
   needed to be changed. From #24, I have c.id and e.id where now, I can replace
   it with Candidate_id and Employee_id or other any name that make sense to the 
   data. This little change is important as organization to do data manipulation 
   where information constantly gets updated.
*/

----------------------------------------------------------------------------------

#26
[LEFT JOIN]

SELECT  
 c.id candidate_id,
 c.fullname candidate_name,
 e.id employee_id,
 e.fullname employee_name
FROM 
 hr.candidates c
 LEFT JOIN hr.employees e 
 ON e.fullname = c.fullname;

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-joins/

[210_IMG26]

/* While example #25 uses inner join, where the data from tables with the condition
   create a combined data as the information. However for #26, LEFT JOIN is used 
   to put more emphasis on 'hr.candidates' and the condition for this LEFT JOIN is
   to find all candidate names that also might be in the 'hr.employees' table. If not
   'null' is present in the employee section.
*/

----------------------------------------------------------------------------------

#27
[RIGHT JOIN]

SELECT  
    c.id candidate_id,
    c.fullname candidate_name,
    e.id employee_id,
    e.fullname employee_name
FROM 
    hr.candidates c
    RIGHT JOIN hr.employees e 
        ON e.fullname = c.fullname;

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-joins/

[210_IMG27]

/* Same as the example above where LEFT JOIN put more emphasis on 'hr.candidates',
   RIGHT JOIN emphasis more on 'hr.employees'. This is where all information of the
   table from employees will appear and if employee is not a candidate, then in 
   'hr.candidate' will appear as NULL
*/

----------------------------------------------------------------------------------

#28
[FULL JOIN]

SELECT  
    c.id candidate_id,
    c.fullname candidate_name,
    e.id employee_id,
    e.fullname employee_name
FROM 
    hr.candidates c
    FULL JOIN hr.employees e 
        ON e.fullname = c.fullname;

Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-joins/

[210_IMG28]

/* FULL JOIN will combine both RIGHT and LEFT JOIN as well can see where both
   employees and candidates have NULL information in their respective column. 
   This gives more visiblility to the overall data, however because it is broad,
   depending on what information is requested, RIGHT and LEFT join will narrow down
   the specific query.
*/

----------------------------------------------------------------------------------

#29
[LEFT JOIN | ORDER BY]

SELECT
    product_name,
    order_id
FROM
    production.products p
LEFT JOIN sales.order_items o ON o.product_id = p.product_id
ORDER BY
    order_id;


Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-left-join/

[210_IMG29]

/* Using LEFT JOIN, provided that the two tables have link between the table column,
   this shows that by querying the product and the order, adn order it by 'order_id',
   would help business to have visiblity which product was not being sold or have any
   orders.
*/

----------------------------------------------------------------------------------

#30
[RIGHT JOIN | WHERE | ORDER BY]

SELECT
    product_name,
    order_id
FROM
    sales.order_items o
    RIGHT JOIN production.products p 
        ON o.product_id = p.product_id
WHERE 
    order_id IS NULL
ORDER BY
    product_name;


Source: http://www.sqlservertutorial.net/sql-server-basics/sql-server-left-join/

[210_IMG30]

/* Alternatively, using RIGHT JOIN will give almost the same result as #29.
   The focus now shift to the product in this RIGHT JOIN. Include 'WHERE' will
   narrow down the search even more concise. That the focus is on the product,
   the query result will only be order_id that is NULL.
*/

----------------------------------------------------------------------------------









